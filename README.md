# Ai Telegram Bot

Телеграм бот для частного ИИ сервера.

Предполагается, что API сервера работает в формате OpenAi.

Возможности:

- включение автоматической регистрации
- ручное одобрение регистрации
- группы пользователей с лимитами
- создание комнат

# Техническое описание

Для примера мы интегрируем бота с Ollama, модель Llama 3.

Пока будет реализован только режим чата.

В дальнейшем будут добавляться другие режимы, такие как генерация изображений и т.д. Каждый режим работы будет определяться типом комнаты.

Чтобы обеспечить создание комнат, сохранение контекста и разделение на пользователей, используется база данных через связь с бэкендом.

Связь с бэкендом также обеспечит возможность создания отдельного приложения и подключение к своему аккаунту не только из чат-бота.

Чтобы обеспечить конфиденциальность запросов пользователей, все сообщения в бд хранятся в зашифрованном виде.

После очистки контекста, удаления комнаты, или удаления пользователя, все связанные сообщения так же удаляются из бд.

# Комнаты

В рамках телеграм бота всегда используется одноуровневый список сообщений.

Смена комнаты никак не влияет на этот список. Так что снаружи этого явно не видно. Чтобы обозначить смену комнаты, бот посылает сообщение.

Переход происходит как бы внутри. После чего вы продолжаете общаться с ботом уже с другими настройками и возможно другой моделью. Контекст меняется, он полностью подтягивается из другой комнаты.

Переключение между комнатами происходит через меню.

Каждая комната хранит настройки.

В настройках комнаты можно задать системные настройки, например

- модель
- системный промпт.

В дальнейшем настройки могут расширяться.

Каждая комната также хранит статистику.

Например:

- общее число использованных токенов/сообщений
- среднее число токенов/сообщений в день
- число токенов/сообщений за последний день
- число токенов/сообщений за текущий месяц

В дальнейшем статистика может расширяться.

Каждая комната имеет владельца.

Доступ нескольких пользователей в одну комнату пока не реализуется.

# Пользователи

Каждая запись пользователя хранит настройки.

В настройках можно задать

- ФИО пользователя
- имя аккаунта в телеграм
- email
- аватар

В дальнейшем настройки могут расширяться.

По каждому пользователю также собирается общая статистика (по всем комнатам).

Например:

- общее число использованных токенов/сообщений
- среднее число токенов/сообщений в день
- число токенов/сообщений за последний день
- число токенов/сообщений за текущий месяц

В дальнейшем статистика может расширяться.

# Роли

Ролевая модель состоит из связи один-к-одному. Каждому пользователю может быть назначена только одна роль.

Каждая роль пользователя хранит лимиты:

- на число комнат,
- на типы комнат,
- на число токенов в день
- на число токенов в в месяц.

В дальнейшем лимиты могут расширяться.

Расширенная ролевая модель, когда у пользователя может быть несколько ролей с разными правами, пока не будет реализована. Сложно представить, как контроливать в подобной ролевой системе лимиты. Но возможно она понадобится в дальнейшем, если будет разрабатываться доступ нескольких пользователей в одну комнату.

## Ролевая модель

RBAC

Управление доступом на основе ролей.

Пользователю присваивается роль. Роль содержит в себе права доступа. Права доступа строятся на основе объектов системы и действий, совершаемых ими.

       | Действие 1 | Действие 2 | Действие 3
---------------------------------------------
Роль 1 | +          | -          | -
Роль 2 | -          | -          | +
Роль 3 | -          | +          | +
Роль 4 | +          | +          | +

ABAC

Управление доступом на основе атрибутов.

Пользовательские атрибуты:

- роль
- отдельного
- уровень доступа
- возраст
...

Атрибуты ресурсов:

- тип ресурса
- классификация
- владелец
- метка безопасности
...

Атрибуты окружения:

- время
- местоположение
- тип устройства
- сетевые условия
...

Политики доступа

XACML - стандарт, разработанный для определения политик доступа.

Цель - например, оформить заказ
Бизнес-правило - например, оформить заказ может только менеджер компании

Отсюда извлекаем набор необходимых атрибутов

Алгоритм комбинации:

- запрещено, если не разрешено
- разрешено, если не запрещено

# Генерация 

Чтобы обеспечить создание комнат, сохранение контекста и разделение на пользователей, используется база данных через связь с бэкендом.

Чтобы обеспечить конфиденциальность запросов пользователей, все сообщения в бд хранятся в зашифрованном виде.

После очистки контекста, удаления комнаты, или удаления пользователя, все связанные сообщения так же удаляются из бд.

# Формат OpenAi API

URL

```
https://your.domain/v1/
```

API-ключ передается в заголовке каждого запроса:

```
Authorization: Bearer YOUR_API_KEY
```

Формат запроса: JSON.

## Чат

HTTP Метод: POST

URL: /v1/chat/completions

Тело запроса:

```
{
  // модель
  "model": "gpt-3.5-turbo",

  // контекст из отправленных ранее сообщений
  "messages": [
    {
      // роль
      "role": "user",

      // ваш текстовый запрос
      "content": "Привет! Как дела?"
    },
    {
      "role": "assistant",
      "content": "Привет! У меня все хорошо, а у тебя?"
    },
    ...
  ],

  // максимальное количество токенов в ответе
  "max_tokens": 100,

  // степень случайности в ответе (от 0 до 1)
  "temperature": 0.7
}
```

В объекте messages необходимо использовать следующие роли:

- user: сообщение от пользователя.
- assistant: сообщение от модели (ChatGPT).
- system: сообщение, которое может задавать поведение модели (опционально).

Ответ API:

```
{
  "id": "chatcmpl-XYZ",
  "object": "chat.completion",
  "created": 1631937584,
  "model": "gpt-3.5-turbo",
  "choices": [
    {
      "message": {
        "role": "assistant",
        "content": "У меня все отлично, спасибо, что спросил! Чем ты занимаешься?"
      },
      "index": 0,
      "finish_reason": "stop"
    }
  ],
  "usage": {
    "prompt_tokens": 20,
    "completion_tokens": 25,
    "total_tokens": 45
  }
}
```

## Генерация текста

HTTP Метод: POST

URL: /v1/completions

Тело запроса:

```
{
  // модель
  "model": "text-davinci-003",

  // ваш текстовый запрос
  "prompt": "Скажите несколько слов о...",

  // максимальное количество токенов в ответе
  "max_tokens": 100,

  // степень случайности в ответе (от 0 до 1)
  "temperature": 0.7,

  // альтернативный способ управления случайностью
  "top_p": 1.0,

  // количество ответов, которые вы хотите получить
  "n": 1,

  // символы, на которых останавливается генерация
  "stop": null
}
```

Ответ API:

```
{
  "id": "cmpl-XYZ",
  "object": "text_completion",
  "created": 1631937584,
  "model": "text-davinci-003",
  "choices": [
    {
      "text": "это сгенерированный текст...",
      "index": 0,
      "logprobs": null,
      "finish_reason": "stop"
    }
  ],
  "usage": {
    "prompt_tokens": 10,
    "completion_tokens": 100,
    "total_tokens": 110
  }
}
```

## Генерация изображений

HTTP Метод: POST

URL: /v1/completions

Тело запроса:

```
{
  // модель
  "model": "davinci",

  // ваш текстовый запрос
  "prompt": "A futuristic cityscape with flying cars and neon lights",

  // степень случайности в ответе (от 0 до 1)
  "temperature": 0.7,

  // количество изображений, которые вы хотите получить
  "n": 2,

  // размер изображения
  "size": "512x512"
}
```

Ответ API:

```
{
  "created": 1631937584,
  "data": [
    {
      "url": "https://example.com/generated_image_1.png"
    },
    {
      "url": "https://example.com/generated_image_2.png"
    }
  ]
}
```

# Шаблон для проектов

- typescript,
- vite,
- vitest,
- eslint,
- prettier,
- electron.

# Начало работы

Создаем новую папку для проекта

```
mkdir my_project
cd my_project
```

Клонируем репозиторий

```
git clone https://github.com/fwmakc/ts-vite-project.git .
```

Устанавливаем

```
yarn
```

# Быстрый запуск

В режиме разработки

```
yarn dev
```

# Запуск под десктоп

В режиме разработки

```
yarn electron:dev
```

## Билд под десктопные устройства

Выполняем предварительную сборку

```
yarn build
```

Собираем приложение под десктоп

```
yarn electron:make
```

Готовое приложение будет лежать в каталоге

```
out/template-vite-ts-win32-x64
```

## Подготовка к сборке под мобильные устройства

Сборку делаем через capacitor. Полностью все происходит в несколько шагов.

Для настройки отредактируйте файл

```
capacitor.config.ts
```

Добавляем мобильное устройство. Это нужно сделать один раз после развертывания проекта.

```
yarn cap add android
```

Созданный каталог android содержит множество настроек приложения, которые хотелось бы сохранить в репозитории. Но он также содержит много временных файлов и копии проекта и поэтому получается слишком большим.

Мы создали другой каталог app, где вы можете хранить все настройки и ресурсы для сборки.

Перед сборкой вам просто нужно скопировать его содержимое

```
cp -rf app/android/* android/app/src/main
```

или

```
xcopy app\android\* android\app\src\main /E /H /C /I /Y
```

Выполняем предварительную сборку

```
yarn build
```

Копируем собранный проект для следующего этапа

```
yarn cap copy
```

## Билд под мобильные устройства

Для дальнейшей сборки под android лучше всего работать в контейнере nodejs из проекта https://github.com/isengine/server.git

Перейдем в каталог

```
cd android
```

Билд в режиме дебаг:

```
./gradlew assembleDebug
```

Готовое приложение будет лежать в каталоге

```
android/app/build/outputs/apk/debug/app-debug.apk
```

Билд в продакшн:

```
./gradlew assembleRelease
```

Готовое приложение теперь будет лежать в каталоге

```
android/app/build/outputs/apk/release/app-release-unsigned.apk
```

Дальнейшие действия лучше выполнять из корневого каталога проекта

```
cd ..
```

Создаем ключ для подписи

```
keytool -genkey -v -keystore MY_RELEASE_KEY.jks -keyalg RSA -keysize 2048 -validity 10000 -alias MY_KEY_ALIAS

```

Запишите созданные пароли и alias, так как они понадобятся вам в дальнейшем.

Создаем копию приложения

```
cp android/app/build/outputs/apk/release/app-release-unsigned.apk android/app/build/outputs/apk/release/app-release.apk
```

Подписываем приложение

```
apksigner sign --ks MY_RELEASE_KEY.jks --ks-key-alias MY_KEY_ALIAS --ks-pass pass:YOUR_KEYSTORE_PASSWORD --key-pass pass:YOUR_KEY_PASSWORD android/app/build/outputs/apk/release/app-release.apk
```

Можно проверить подпись

```
apksigner verify android/app/build/outputs/apk/release/app-release.apk
```

Если APK подписан правильно, вы не увидите никаких ошибок.

# Тестирование

Тестируем с помощью vitest.

Vitest очень похож на jest, но сразу оптимизирован для использования с typescript и vite. С его помощью можно также тестировать DOM-элементы.

Примеры использования приведены в проекте.

Помещаем файл рядом с объектом тестирования и называем так же, но с расширением **.test.ts**.

Пример:

```
src/counter.ts
src/counter.test.ts
```

Второй вариант - помещаем в папку **src/tests** и так же даем расширение **.test.ts**.

Пример:

```
src/tests/example.test.ts
```

Для запуска всех тестов используем команду

```
yarn test
```

Чтобы запустить какой-либо определенный тест, указываем его в качестве аргумента:

```
yarn test ./src/tests/example.test.ts
```

# Лицензия

Лицензия MIT, 2025
